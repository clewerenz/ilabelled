---
title: "overview"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

```{r setup, echo=FALSE,message=FALSE}
library(ilabelled)
```

# General

ilabelled was developed to address a fundamental problem in labeling values in R: 

  1. Underlying values should not be changed when value labels are added (as is the case with the factor class). 
  2. Value labels as well as underlying values should be able to be used as indices. 

In addition, the i_labelled class should encourage users to think directly about meta information about variables in the work process and add it to the variables.

The basic idea behind this endeavor is to enable a similar handling of survey data as is the case in common social science statistical software such as SPSS or STATA.

## Class declaration

ilabelled offers the option of declaring individual vectors or all vectors in a data.frame as an object i_labelled. Additional meta information is added as attributes. Additional information can be viewed transparently using a class-specific print method.

In principle, adding additional information is optional. As mentioned above, the class-specific syntax is intended to encourage meta information to be included. 

```{r}
set.seed(1234)

myVar <- i_labelled(
  x = sample(c(1:3,-9), 50, replace = TRUE), 
  label = "Gender",
  labels = c(
    "A" = 1,
    "B" = 2,
    "C" = 3,
    "X" = -9
  ),
  na_values = -9,
  subject = "Personal information",
  wording = "What is your gender",
  scale = "nominal"
)
myVar

```


### factor to i_labelled

Value labels are automatically assigned for vectors of class factor. In contrast to the base R factor class, underlying values and labels can be addressed directly for i_labelled objects.

```{r}
myData <- factor(c(1, 2, 3, NA), levels = 1:3, labels = c("A", "B", "C"))
myData <- i_labelled(myData)
myData
myData %in% "A"
myData == 1
```


# Indexation

One of the fundamental features of i_labelled objects is that both underlying values and value labels can be used for logical operations. 

The following rules must be observed when indexing i_labelled objects: 

  1. If numerical values are used for the indexation of numerical i_labelled data, the underlying numerical values of the i_labelled data are used for the comparison. 
  2. If character values or values of class i_labelled are used for indexation, *value labels are always used over the underlying values of the i_labelled data*.


## Example 1: Indexation of unterlying data

```{r}
myData <- i_labelled(
  x = c(1, 2, 3, NA), 
  labels = c("A" = 1, "B" = 2, "C" = 3), 
  label = "my Variable"
)

myData %in% 1
myData == 1
myData > 1
```


## Example 2: Indexation of value labels

Keep in mind, if character values are used for indexation, value labels are alway chosen over underlying values.

```{r}
myData %in% c("A", "B")
myData != "C"
myData > "A"
```


# Meta Information

Meta information that is part of i_labeled objects: 
  
  1. *label*: Variable label 
  2. *labels*: Value labels 
  3. *na_values*: Missing values 
  4. *na_range*: Missing range 
  5. *scale*: Scale level 
  6. *wording*: Question text in the questionnaire 
  7. *subject*: Subject of the variable 
  8: *annotation*: Additional information 

Meta information can be applied via the class constructor i_labelled (as seen above) or by dedicated functions. Adding meta information by base R's <code>attr()</code> function is also possible.

```{r}
myVariable <- i_labelled(c(1, 2, 3, -9, NA))

myVariable <- myVariable |>
  i_label("my variable label") |>
  i_labels(
    "A" = 1,
    "B" = 2,
    "C" = 3,
    "X" = -9
  ) |>
  i_na_range(c(-9,-1)) |>
  i_scale("nominal") |>
  i_subject("dummy data")
myVariable
```


# Class coercion

Objects of type i_labelled can be very easily converted into base R object classes. On the one hand, this is possible using the familiar <code>as.*</code> methods. On the other hand, there are specific functions in which value labels are taken into account: <code>i_as_factor()</code> and <code>i_as_character</code>

If R's own method as.* is used, the underlying data is converted accordingly. Value labels are not taken into account.

```{r}
myData <- i_labelled(
  x = c(1, 2, 3, NA), 
  labels = c("A" = 1, "B" = 2), 
  label = "my Variable"
)
as.character(myData)
as.numeric(myData)
as.factor(myData)
```


However, ilabelled also offers two specific functions that take value labels into account during conversion.

```{r}
myData <- i_labelled(
  x = c(1, 2, 3, NA, -9), 
  labels = c("A" = 1, "B" = 2, "X" = -9), 
  label = "my Variable",
  na_values = -9
)
i_as_factor(myData, missing_to_na = FALSE, keep_attributes = FALSE)
i_as_character(myData, missing_to_na = TRUE, keep_attributes = TRUE)
```
